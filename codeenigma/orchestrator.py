import os
from pathlib import Path
from shutil import rmtree

import rich

from codeenigma.core import obfuscate_file
from codeenigma.private import NONCE, SECRET_KEY


class Orchestrator:
    def __init__(self, module_path: str, output_dir: str = "dist"):
        self.module_path = Path(module_path)
        self.output_dir = Path(output_dir)

    def create_obfuscation_file(self, file_path: str, output_path: str):
        secure_code = obfuscate_file(file_path)
        runtime_embedded_code = f"""
# This file is auto-generated by codeenigma. Do not edit !!!
# Origin: {Path(file_path).name}

from codeenigma_runtime import execute_secure_code
execute_secure_code({repr(secure_code)}, globals())
"""
        # Write the obfuscated module
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(runtime_embedded_code)

    def generate_setup(self):
        setup_code = """
import os

from Cython.Build import cythonize
from setuptools import find_packages, setup
from setuptools.extension import Extension

# Get the current directory
current_dir = os.path.dirname(os.path.abspath(__file__))

# Define the extension module
codeenigma_extension = Extension(
    name="codeenigma_runtime",
    sources=[os.path.join(current_dir, "codeenigma_runtime.pyx")],
    extra_compile_args=["-O3", "-fPIC"],
    language="c",
)

# Setup configuration
setup(
    name="codeenigma_runtime",
    version="0.1.0",
    description="Python code obfuscation tool using AES and Base64 encryption",
    ext_modules=cythonize(
        [codeenigma_extension],
        compiler_directives={
            "language_level": 3,
            "boundscheck": False,
            "wraparound": False,
            "initializedcheck": False,
            "nonecheck": False,
            "cdivision": True,
            "c_string_type": "str",
            "c_string_encoding": "utf8",
            "legacy_implicit_noexcept": False,
        },
        nthreads=4,
    ),
    packages=find_packages(),
    zip_safe=False,
)
"""
        with open("codeenigma_setup.py", "w", encoding="utf-8") as f:
            f.write(setup_code)

    def generate_runtime(self):
        """Generate the runtime code."""
        runtime_code = f"""
import base64
import marshal
import zlib
import types

from cryptography.hazmat.primitives.ciphers.aead import AESGCM

NONCE = {NONCE}
SECRET_KEY = {SECRET_KEY}

def execute_secure_code(secure_code: bytes, globals_dict=None) -> bytes:

    if globals_dict is None:
        globals_dict = globals()

    # Decrypt the obfuscated code
    aesgcm = AESGCM(SECRET_KEY)
    decrypted = aesgcm.decrypt(NONCE, secure_code, associated_data=None)

    # Decode and decompress
    compressed = base64.b64decode(decrypted)
    marshaled = zlib.decompress(compressed)

    # Unmarshal to get the code object
    code_obj = marshal.loads(marshaled)

    if isinstance(code_obj, types.CodeType):
        exec(code_obj, globals_dict)
    else:
        raise ValueError("Invalid code object in obfuscated module")
"""
        with open("codeenigma_runtime.pyx", "w", encoding="utf-8") as f:
            f.write(runtime_code)

        # Generate the setup.py file
        self.generate_setup()

        # run setup.py to compile the Cython code
        import subprocess

        subprocess.run(
            ["poetry", "run", "python", "codeenigma_setup.py", "build_ext", "--inplace"]
        )

        # Clean up the temporary files
        os.remove("codeenigma_setup.py")
        os.remove("codeenigma_runtime.pyx")
        os.remove("codeenigma_runtime.c")
        rmtree("build", ignore_errors=True)

        # Move the generated .so file to the output directory
        import platform
        import shutil
        import sys

        # Get Python version and platform
        py_version = f"{sys.version_info.major}{sys.version_info.minor}"
        platform_str = platform.system().lower()
        so_file = f"codeenigma_runtime.cpython-{py_version}-{platform_str}.so"

        # Copy the generated .so file to the output directory
        shutil.move(so_file, self.output_dir / so_file)

    def obfuscate_module(self):
        """Obfuscate the entire module."""
        rich.print("\n[bold blue] Starting obfuscation process...[/bold blue]")

        for py_file in self.module_path.glob("**/*.py"):
            rich.print(f"[bold white] Obfuscating {py_file}[/bold white]")
            # Get relative path for module structure
            rel_path = py_file.relative_to(self.module_path.parent)
            output_path = self.output_dir / rel_path
            output_path.parent.mkdir(parents=True, exist_ok=True)

            self.create_obfuscation_file(py_file, output_path)

        # Generate the runtime code
        rich.print("\n[bold blue]Generating runtime code...[/bold blue]")
        self.generate_runtime()

        rich.print(
            f"\n[green]Obfuscation complete. Files saved to: {self.output_dir}/[/green]",
        )
